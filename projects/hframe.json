{
  "title": "HFrame",
  "cardImage": "/hframe.png",
  "projectImage": "/hframe.png",
  "shortDescription": "Canvas-based UI framework built with TypeScript",
  "github": "https://github.com/hikitechnology/hframe",
  "demo": "https://hikitechnology.github.io/hframe/",
  "tags": [
    "TypeScript",
    "OOP"
  ],
  "inDevelopment": false,
  "tagline": "Canvas UI Framework",
  "longDescription": "HFrame is an experimental JS/TS framework that renders to a canvas instead of the DOM. Interactive webapps are often limited in performance by the browser's HTML tree parsing - for deeply nested structures, the browser may recalculate the size and position of hundreds of elements at a time. HFrame avoids intensive DOM manipulation by rendering the app to a canvas instead of HTML elements.\nHFrame was the first project I made after reading Code Complete 2 and Head First Design Patterns. Its primary purpose was to help me practice the OOP concepts introduced within those books.",
  "status": "Backburner",
  "timeline": "2 months",
  "role": "Developer",
  "team": "Solo Project",
  "techStack": [
    {
      "category": "Frontend",
      "icon": "globe",
      "items": [
        {
          "name": "TypeScript",
          "description": "Type-safe development"
        }
      ]
    },
    {
      "category": "Developer Tooling",
      "icon": "wrench",
      "items": [
        {
          "name": "Vite",
          "description": "TypeScript build tool"
        }
      ]
    }
  ],
  "features": [
    {
      "title": "Composability",
      "description": "In HFrame, all UI components implement the \"element\" interface, including layout components. Accordingly, layouts and elements can be composed together to create complex application interfaces and compound elements.",
      "icon": "box"
    },
    {
      "title": "Object-Oriented Design",
      "description": "The design of HFrame adheres to the OOP principles of abstraction, encapsulation, inheritance, and polymorphism. Classes are programmed with high cohesion, and browser APIs are abstracted to reduce complexity.",
      "icon": "braces"
    },
    {
      "title": "Flexbox-like Layouts",
      "description": "Components can be laid out using absolute sizes (in pixels), or percentages of the parent component. Panels can be resized by dragging their edges.",
      "icon": "layout-template"
    },
    {
      "title": "Styling and Themes",
      "description": "HFrame's default themes can be extended and customized using the ThemeBuilder. Styles of individual components can also be customized inline by the user.",
      "icon": "brush"
    }
  ],
  "challenges": [
    {
      "problem": "Implementing Flexbox-like Layouts",
      "solution": "Creating a flexbox-like layout system on canvas was difficult, since canvas lacks native layout engines like CSS. Calculating relative positions and sizes required recursive calculation of component sizes based on parent dimensions.",
      "code": "// Method to get allocated rectangle of a child component in a directional layout\n\nprotected getAllocRect(baseRect: Rect, element: Element) {\n  const allocation = this.getAllocation(element);\n\n  // find the x/y coord to find the allocation rect at\n  let offset = 0;\n  for (const alloc of this.allocations) {\n    if (alloc === allocation) {\n      break;\n    }\n    if (alloc.type === \"pixel\") {\n      offset += alloc.size;\n    } else {\n      offset +=\n        (alloc.size / this.sumRelativeAllocations()) *\n        ((this.isVertical ? baseRect.height : baseRect.width) -\n          this.sumPixelAllocations());\n    }\n  }\n\n  const x = baseRect.x + (this.isVertical ? 0 : offset);\n  const y = baseRect.y + (this.isVertical ? offset : 0);\n\n  const thisAllocSize =\n    allocation.type === \"pixel\"\n      ? allocation.size\n      : (allocation.size / this.sumRelativeAllocations()) *\n        ((this.isVertical ? baseRect.height : baseRect.width) -\n          this.sumPixelAllocations());\n\n  const width = this.isVertical ? baseRect.width : thisAllocSize;\n  const height = this.isVertical ? thisAllocSize : baseRect.height;\n\n  return Rect.from(x, y, width, height);\n}"
    },
    {
      "problem": "Handling Resize Interactions",
      "solution": "Implementing draggable panel resizing was tricky, and manually checking the distance of the cursor to element boundaries created unnecessary complexity. To handle geometric operations in a more declarative way, I created several shape classes - points, line segments, and rectangles - and composed them together, abstracting away mathematical formulas for distance, overlap, transformations, and more.",
      "code": "import { LineSegment } from \"./line-segment\";\nimport { Pos2D } from \"./pos2d\";\nimport { Vec2D } from \"./vec2d\";\n\n/**\n * Rectangle in a 2D space\n */\nexport class Rect {\n  /**\n   * Constructs a new Rect\n   * @param position - position of the top left corner\n   * @param size - size vector\n   */\n  constructor(\n    private position: Pos2D,\n    private size: Vec2D,\n  ) {}\n\n  /**\n   * Constructs a new rect\n   * @param x - x coordinate of top left corner\n   * @param y - y coordinate of top left corner\n   * @param width - width of the rectangle\n   * @param height - height of the rectangle\n   */\n  static from(x: number, y: number, width: number, height: number) {\n    return new Rect(new Pos2D(x, y), new Vec2D(width, height));\n  }\n\n  equals(other: Rect) {\n    return this.position.equals(other.position) && this.size.equals(other.size);\n  }\n\n  /**\n   * Check if the Rect contains a Pos2D point, with optional leeway\n   * @param position - Pos2D point\n   * @param leeway - tolerated distance from rect (default 0)\n   */\n  contains(position: Pos2D, leeway: number = 0) {\n    const leftEdge = this.position.x - leeway;\n    const rightEdge = this.position.x + this.size.x + leeway;\n\n    const topEdge = this.position.y - leeway;\n    const bottomEdge = this.position.y + this.size.y + leeway;\n\n    const hContains = leftEdge <= position.x && position.x <= rightEdge;\n    const vContains = topEdge <= position.y && position.y <= bottomEdge;\n\n    return hContains && vContains;\n  }\n\n  /**\n   * Grows a Rect from its center by the given distance on each side, and returns itself\n   * Shrinks the Rect if the value is negative\n   * @param growBy - How much to shrink each side by\n   */\n  grow(growBy: number): Rect {\n    this.x -= growBy;\n    this.y -= growBy;\n    this.width += growBy * 2;\n    this.height += growBy * 2;\n    return this;\n  }\n\n  /**\n   * Check if a Rect intersects with another Rect\n   * @param other: Other Rect\n   */\n  intersects(other: Rect): boolean {\n    return (\n      this.x <= other.x + other.width &&\n      other.x <= this.x + this.width &&\n      this.y <= other.y + other.height &&\n      other.y <= this.y + this.height\n    );\n  }\n\n  /**\n   * Returns a copy of this Rect\n   */\n  clone(): Rect {\n    return new Rect(this.position.clone(), this.size.clone());\n  }\n\n  // ----- getters & setters -----\n  get x() {\n    return this.position.x;\n  }\n\n  set x(x) {\n    this.position.x = x;\n  }\n\n  ...\n}"
    }
  ],
  "process": [
    {
      "phase": "Learning & Early Development",
      "duration": "1 month",
      "description": "Began experimenting with the canvas framework idea as a way to practice the OOP concepts I had read about prior. Began working on the project, scrapped everything, and restarted multiple times as I gained footing."
    },
    {
      "phase": "Current Stage",
      "duration": "1 month",
      "description": "Began working on the current version of HFrame, with the knowledge and practice I gained from working on the previous iterations. Became more comfortable with the OOP paradigm as I practiced."
    }
  ]
}
